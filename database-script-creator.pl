#!/usr/bin/perl -w

if ( scalar @ARGV != 4 ) {
	die "usage: $0 sql-dbs sql-roles sql-drops postgisdbs

Read Postgresql database dump from stdin and write a modified version to
stdout. The following modifications will be made:
- all CREATE DATABASE clauses will be removed
- all CREATE ROLE clauses will be removed
- all definitions of Postgis supplied functions will be removed
  (these functions are typically generated by sql scripts from postgis)

While processing the following files will be written named by parameters:
sql-dbs: CREATE DATABASE clauses in SQL format to recreate the databases
sql-roles: CREATE ROLE clauses in SQL format to recreate the roles
sql-drops: SQL script to drop all databases and roles created
postgisdbs: a plain text file of one database name per line of
        all those databases encountered which had postgis functions in them.

The script is used to generate files which may be used to restore a
database regardless of postgis version possibly used. Also, the
created restore file will run whether the databases and roles are there
already.

To use resulting files:
- run sql-dbs and sql-roles
- run postgis installation sqls for all databases named in postgisdbs
- run the output of this command

To remove test data run sql-drops(NOTE: it will remote ALL data in those databases).

WARNING: running this command will overwrite anything already in the
files named by parameters
";

}

open DATABASES, ">" . $ARGV[0];
open ROLES,     ">" . $ARGV[1];
open DROPS,     ">" . $ARGV[2];

my $currentdb       = "";
my $currentfunction = "";
my $functionbody    = "";
my %postgisdbs      = ();

while (<STDIN>) {
	my $line = $_;

	# Track current database
	if ( $line =~ m/^\\connect ([a-zA-Z0-9_]*)/ ) {
		$currentdb = $1;
	}

	# Put roles in a separate file and create role drops
	if ( $line =~ m/^CREATE ROLE ([a-z_]*)/ ) {

		# Don't try to recreate postgres
		if ( $1 eq "postgres" ) {
			next;    # Go to next line
		}
		print DROPS "DROP ROLE IF EXISTS $1;\n";
		print ROLES $line;
		next;
	}

	# Create databases in a separate script
	if ( $line =~ m/^CREATE DATABASE ([a-z0-9_]*)/ ) {
		print DATABASES $line;
		print DROPS "DROP DATABASE IF EXISTS $1;\n";
		next;
	}

	# Create schemas in the database script
	if ( $line =~ m/^CREATE SCHEMA ([A-Za-z_]*)/ ) {
		print DATABASES "\\connect $currentdb\n";
		print DATABASES $line;
		next;
	}
	
	# Skip owner to postgres changes - will be running as postgres anyway
	if ( $line =~ m/^ALTER .* OWNER TO postgres;/ ) {
		next;
	}

	# Skip postgis functions
	if ($currentfunction) {
		$functionbody .= $line;
		if ( $line =~ /;\s*$/ ) {
			$currentfunction = "";

			# Function body ends, remove postgis functions, print others
			if ( $functionbody =~ m/AS '[^']*postgis/ ) {
				$postgisdbs{$currentdb} = 1;
				next;
			}
			else {
				print $functionbody;
				next;
			}
		}
		else {
			# Function body continues, save it but don't print yet
			next;
		}
	}
	if ( $line =~ m/^CREATE FUNCTION ([a-zA-Z_.]*)/ ) {
		$currentfunction = $1;
		$line =~ s/^CREATE FUNCTION/CREATE OR REPLACE FUNCTION/;
		$functionbody = $line;
		next;
	}

	# Change some definition to create or replace
	if ( $line =~ m/^CREATE RULE / ) {
		$line =~ s/^CREATE RULE/CREATE OR REPLACE RULE/;
	}

	# Remove certain role options not available in pre-9.5 Postgresql
	if ( $line =~ m/^ALTER ROLE / ) {
		$line =~ s/ NOBYPASSRLS//;
		$line =~ s/ BYPASSRLS//;
	}

	# Remove some other options not available in pre-9.5 Postgresql
	if ( $line =~ m/^SET ([a-z_]*)/ ) {
		if ( $1 eq "lock_timeout" ) { next; }
		if ( $1 eq "row_security" ) { next; }
	}

	# Remove some commands as they are actually defined by Postgis
	if ( $line =~ m/^CREATE CAST / ) {
		next;
	}
	if ( $line =~ m/^([A-Z]+ [A-Z]+)[A-Z ]* public[.]([a-z0-9_]*)/ ) {
		my $cmdtype = $1;
		my $type    = $2;

		# Skip operators and casts completely
		if ( $cmdtype eq 'CREATE OPERATOR' ) {
			if ( $line !~ m/;\s$/ ) {
				while (<STDIN>) {
					$line = $_;
					if ( $line =~ m/;\s$/ ) {
						last;
					}
				}
			}
			next;
		}
		elsif ($cmdtype eq 'CREATE TABLE'
			|| $cmdtype eq 'ALTER TABLE'
			|| $cmdtype eq "CREATE VIEW"
			|| $cmdtype eq "CREATE TYPE"
			|| $cmdtype eq "CREATE AGGREGATE" )
		{
			my @list = ();
			if (   $cmdtype eq 'CREATE TABLE'
				|| $cmdtype eq 'CREATE VIEW'
				|| $cmdtype eq 'ALTER TABLE' )
			{
				@list = ( 'geography_columns', 'geometry_columns',
					'spatial_ref_sys' );
			}
			if ( $cmdtype eq 'CREATE TYPE' ) {
				@list = (
					'box2d',    'box2df',        'box3d', 'geography',
					'geometry', 'geometry_dump', 'gidx',  'pgis_abs',
					'spheroid', 'valid_detail'
				);
			}
			if ( $cmdtype eq 'CREATE AGGREGATE' ) {
				@list = (
					'st_3dextent', 'st_accum',
					'st_collect',  'st_extent',
					'st_makeline', 'st_memcollect',
					'st_memunion', 'st_polygonize',
					'st_union'
				);
			}
			foreach my $reftype (@list) {
				if ( $type eq $reftype ) {

					# Removing this type, skip lines until ;, if necessary
					if ( $line !~ m/;\s$/ ) {
						while (<STDIN>) {
							$line = $_;
							if ( $line =~ m/;\s$/ ) {
								last;
							}
						}
					}
					$type =
					  "";    # This indicates we found one of the types listed
					last;
				}
			}

			# Cannot go to next from inner loop, have to do it here
			if ( !$type ) {
				next;
			}

		}
	}

	# Print the possibly modified line if we got this far
	print $line ;
}

# Output databases requiring postgis extensions
open POSTGIS, ">$ARGV[3]";
foreach my $db ( sort keys %postgisdbs ) {
	print POSTGIS "$db\n";
}
